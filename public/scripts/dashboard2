/**
 * ====================================================================
 * DASHBOARD APP - REWRITE COMPLETA
 * Codice unificato, completo e pronto per il copy-paste (ES6 Classes)
 * * Inserisce tutta la logica originale (Auth, API, UI, Flashcards, Debrief)
 * in un'unica struttura coesa.
 * ====================================================================
 */

// --------------------------------------------------------------------
// 1. CONFIGURAZIONE E COSTANTI (Config & Constants)
//    Assicurati che questi ID DOM esistano nel tuo HTML.
// --------------------------------------------------------------------
const CONFIG = {
    // ‚ö†Ô∏è SOSTITUISCI CON I TUOI VALORI REALI
    API_BASE_URL: "https://vercel-python-proxy.vercel.app/api",
    DEPLOYMENT_ID: "AKfycbwjmnBDZcMdBmP6Dj67S19qGDP61ujNtBvJZU65xqlUfluThOy1pphwjvACS9FVXJeD",
    
    SESSION_KEY: "coachSession",
    
    // Lista completa di tutti gli ID DOM usati nell'applicazione
    DOM_REFS: {
        // Sezioni Principali
        loginSection: 'loginSection',
        dashboardSection: 'dashboardSection',
        callSection: 'callSection',
        coachingDebriefSection: 'coachingDebriefSection',
        callHistorySection: 'callHistorySection',
        studentsSection: 'studentsSection',
        flashcardsSection: 'flashcardsSection',

        // Auth
        loginForm: 'loginForm',
        coachIdInput: 'coachId',
        passwordInput: 'password',
        loginMessageBox: 'loginMessageBox',
        googleLoginContainer: 'googleLoginContainer',
        logoutBtn: 'logoutBtn',

        // Globals & Helpers
        globalLoader: 'globalLoader',
        toast: 'toast',
        coachNameDisplay: 'coachNameDisplay',
        callSectionCoachNameDisplay: 'callSectionCoachNameDisplay',
        earningsAmountDisplay: 'earningsAmount',
        viewFolderBtn: 'viewFolderBtn',

        // Sezione Call Log
        callLogForm: 'callLogForm',
        callLogStudentSelect: 'callLogStudentSelect',
        callLogMessageBox: 'callLogMessageBox',
        // (Aggiungi qui tutti gli ID del form call log)

        // Sezione Studenti
        studentSelect: 'studentSelect',
        studentDetailsContainer: 'studentDetailsContainer',
        backToDashboardFromStudentsBtn: 'backToDashboardFromStudentsBtn',

        // Sezione Debrief
        debriefStudentSelect: 'debriefStudentSelect',
        debriefDateInput: 'debriefDateInput',
        debriefMsg: 'debriefMsg', // Message box per Debrief
        debriefLoadDraftsBtn: 'debriefLoadDraftsBtn',
        debriefDraftsContainer: 'debriefDraftsContainer',
        debriefForm: 'coachingDebriefForm',
        debriefSaveDraftBtn: 'debriefSaveDraftBtn',
        debriefSendBtn: 'debriefSendBtn',
        debriefAIPreviewContainer: 'debriefAIPreviewContainer',
        
        // Sezione History
        callHistoryTableBody: 'callHistoryTableBody',
        historyMonthYear: 'historyMonthYear',

        // Sezione Flashcards
        flashcardsContainer: 'flashcardsContainer',
        flashcardsStudentSelect: 'flashcardsStudentSelect',
        flashcardCardContainer: 'flashcardCardContainer',
        flashcardControlsContainer: 'flashcardControlsContainer',
        flashcardFront: 'flashcardFront',
        flashcardBack: 'flashcardBack',
        flashcardStepDisplay: 'flashcardStepDisplay',
        flashcardProgress: 'flashcardProgress',
        flashcardDeckTotal: 'flashcardDeckTotal',
        flashcardGoodBtn: 'flashcardGoodBtn',
        flashcardBadBtn: 'flashcardBadBtn',
        flashcardSendUpdatesBtn: 'flashcardSendUpdatesBtn',
        flashcardRetryRedsBtn: 'flashcardRetryRedsBtn',
    }
};

// --------------------------------------------------------------------
// 2. SERVIZIO API (APIService Class)
// Gestisce tutte le interazioni con l'endpoint esterno.
// --------------------------------------------------------------------
class APIService {
    constructor(baseUrl, deploymentId) {
        this.baseUrl = baseUrl;
        this.deploymentId = deploymentId;
    }

    async get(action, params = {}) {
        const url = new URL(`${this.baseUrl}/get`);
        url.searchParams.set("deployment_id", this.deploymentId);
        url.searchParams.set("action", action);
        url.searchParams.set("_ts", Date.now());

        Object.entries(params).forEach(([k, v]) => {
            if (v !== undefined && v !== null) url.searchParams.set(k, v);
        });

        const res = await fetch(url.toString());
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`GET ${action} failed: ${res.status} ${res.statusText}. Response: ${errorText.substring(0, 100)}...`);
        }
        return res.json();
    }

    async post(action, body = {}) {
        const res = await fetch(`${this.baseUrl}/post`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                deployment_id: this.deploymentId,
                action,
                ...body
            })
        });
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`POST ${action} failed: ${res.status} ${res.statusText}. Response: ${errorText.substring(0, 100)}...`);
        }
        return res.json();
    }
}

// --------------------------------------------------------------------
// 3. UTILITY E GESTIONE UI (UIManager Object)
// Consolida tutte le funzioni helper DOM.
// --------------------------------------------------------------------
const UIManager = {
    // Riferimenti DOM (recuperati una sola volta)
    refs: {},

    initRefs: () => {
        for (const [key, id] of Object.entries(CONFIG.DOM_REFS)) {
            UIManager.refs[key] = document.getElementById(id);
        }
    },

    showGlobalLoader: () => {
        UIManager.refs.globalLoader?.classList.add('active');
    },

    hideGlobalLoader: () => {
        UIManager.refs.globalLoader?.classList.remove('active');
    },

    showToast: (msg, ms = 4000, color = "bg-green-600") => {
        const t = UIManager.refs.toast;
        if (!t) return;
        // Rimuovi tutte le classi di colore esistenti prima di applicare la nuova
        t.className = t.className.replace(/\b(bg-red-600|bg-green-600|bg-yellow-600)\b/g, '');
        t.className = `fixed top-4 right-4 text-white px-4 py-2 rounded-lg shadow-lg z-[99999] hidden ${color}`;
        t.textContent = msg;
        t.classList.remove("hidden");
        setTimeout(() => { t.classList.add("hidden"); }, ms);
    },

    switchSection: (sectionId) => {
        document.querySelectorAll('.app-section').forEach(el => el.classList.add('hidden'));
        const showEl = UIManager.refs[sectionId];
        if (showEl) showEl.classList.remove('hidden');
        window.scrollTo({ top: 0, behavior: 'auto' });
        // Logica per l'evidenziazione del menu (omessa ma da aggiungere in base al tuo HTML)
        document.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
        document.querySelector(`.nav-link[data-section="${sectionId}"]`)?.classList.add('active');
    },

    loaderHTML: (message = "Loading...") => {
        return `
            <div class="flex flex-col items-center justify-center py-4 text-gray-500">
              <div class="spinner-container mb-2">
                <div class="spinner-dot"></div>
                <div class="spinner-dot"></div>
                <div class="spinner-dot"></div>
              </div>
              <p>${message}</p>
            </div>
        `;
    },

    showMessage: (boxElement, message, isSuccess = true) => {
        if (!boxElement) return;
        boxElement.classList.remove('hidden', 'bg-red-100', 'bg-green-100');
        boxElement.classList.add(isSuccess ? 'bg-green-100' : 'bg-red-100');
        boxElement.innerHTML = `<p class="${isSuccess ? 'text-green-800' : 'text-red-800'}">${message}</p>`;
    },
    
    hideMessage: (boxElement) => {
        if (!boxElement) return;
        boxElement.classList.add('hidden');
        boxElement.innerHTML = '';
    },
    
    capitalize: (s) => s.charAt(0).toUpperCase() + s.slice(1),
    escapeHTML: (str) => String(str).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])),
    normalizeUrl: (u) => {
        const s = String(u || '').trim();
        if (!s) return "";
        if (/^https?:\/\//i.test(s)) return s;
        return "https://" + s;
    }
};

// --------------------------------------------------------------------
// 4. CLASSE PRINCIPALE (DashboardApp)
// Contiene lo stato e tutta la logica di business.
// --------------------------------------------------------------------
class DashboardApp {
    // Stato (variabili originali migrate a propriet√† della classe)
    #coach = {
        id: null,
        name: null,
        role: null
    };
    #api;
    #studentsData = {}; // Cache dati studenti
    #callHistory = [];
    #debriefLoadedRow = null;
    
    // Stato Flashcards
    #pendingFlashcardUpdates = [];
    #stepIndex = 0;
    #sessionTotalSteps = 20; // Default come nell'originale
    #cardsByEn = new Map();
    #currentDeck = [];
    #renderNextCard = null;


    constructor() {
        UIManager.initRefs();
        this.#api = new APIService(CONFIG.API_BASE_URL, CONFIG.DEPLOYMENT_ID);
        this.initEventListeners();
    }

    /**
     * Punto di ingresso dell'applicazione.
     */
    async init() {
        const sessionRestored = this.restoreSession();

        if (sessionRestored) {
            UIManager.switchSection(CONFIG.DOM_REFS.dashboardSection);
            this.updateCoachDisplay();
            this.loadDashboardData();
        } else {
            UIManager.switchSection(CONFIG.DOM_REFS.loginSection);
        }
    }

    // ------------------- GESTIONE AUTENTICAZIONE E SESSIONE -------------------

    restoreSession() {
        const session = localStorage.getItem(CONFIG.SESSION_KEY);
        if (session) {
            try {
                const data = JSON.parse(session);
                this.#coach.id = data.id;
                this.#coach.name = data.name;
                this.#coach.role = data.role;
                return true;
            } catch (e) {
                localStorage.removeItem(CONFIG.SESSION_KEY);
            }
        }
        return false;
    }
    
    saveSession(coachData) {
        this.#coach.id = String(coachData.coachId);
        this.#coach.name = coachData.coachName || this.#coach.id;
        this.#coach.role = coachData.role;

        localStorage.setItem(CONFIG.SESSION_KEY, JSON.stringify(this.#coach));
        this.updateCoachDisplay();
        UIManager.refs.googleLoginContainer?.classList.add('hidden');
    }

    async handleManualLogin(e) {
        e.preventDefault();
        UIManager.hideMessage(UIManager.refs.loginMessageBox);
        UIManager.showGlobalLoader();

        try {
            const coachId = UIManager.refs.coachIdInput.value.trim();
            const password = UIManager.refs.passwordInput.value.trim();
            
            const resp = await this.#api.post('login', { coachId, password });
            
            if (!resp.success) throw new Error(resp.error || 'Login fallito');
            if (!resp.role) throw new Error("Ruolo coach non trovato.");

            this.saveSession(resp);
            UIManager.switchSection(CONFIG.DOM_REFS.dashboardSection);
            
            await this.loadDashboardData();
        } catch (err) {
            UIManager.showMessage(UIManager.refs.loginMessageBox, err.message || String(err), false);
        } finally {
            UIManager.hideGlobalLoader();
        }
    }
    
    // Funzione resa globale per il widget Google, poi chiamata da qui
    async handleGoogleLogin(response) {
        UIManager.showGlobalLoader();
        try {
            const credential = response.credential;
            const resp = await this.#api.post("loginWithGoogle", { credential });

            if (!resp.success) {
                UIManager.showToast("Google login fallito: " + resp.error, 5000, "bg-red-600");
                return;
            }

            this.saveSession(resp);
            UIManager.switchSection(CONFIG.DOM_REFS.dashboardSection);
            
            await this.loadDashboardData();
        } catch (err) {
            UIManager.showToast("Errore login Google: " + (err.message || err), 5000, "bg-red-600");
        } finally {
            UIManager.hideGlobalLoader();
        }
    }

    handleLogout() {
        this.#coach = { id: null, name: null, role: null };
        this.#studentsData = {};
        localStorage.removeItem(CONFIG.SESSION_KEY);
        UIManager.refs.coachIdInput.value = "";
        UIManager.refs.passwordInput.value = "";
        UIManager.refs.googleLoginContainer?.classList.remove('hidden');
        UIManager.switchSection(CONFIG.DOM_REFS.loginSection);
        UIManager.hideMessage(UIManager.refs.loginMessageBox);
    }

    // ------------------- CARICAMENTI DASHBOARD/INIZIALI -------------------

    updateCoachDisplay() {
        const name = this.#coach.name || 'Coach';
        UIManager.refs.coachNameDisplay.textContent = name;
        UIManager.refs.callSectionCoachNameDisplay.textContent = name;
    }

    async loadDashboardData() {
        // Caricamenti secondari in parallelo
        await Promise.allSettled([
            this.fetchMonthlyEarnings(),
            this.loadStudentsForCallLog(),
        ]);
    }

    async fetchMonthlyEarnings() {
        if (!this.#coach.id) return;
        UIManager.refs.earningsAmountDisplay.textContent = '...';
        try {
            const resp = await this.#api.get('getMonthlyEarnings', { coachId: this.#coach.id });
            const value = (resp && resp.success) ? resp.earnings : 0;
            UIManager.refs.earningsAmountDisplay.textContent = Number(value).toFixed(2);
        } catch (err) {
            UIManager.refs.earningsAmountDisplay.textContent = '--';
        }
    }
    
    async handleViewFolder() {
        if (!this.#coach.id) return;
        UIManager.showGlobalLoader();
        try {
            const resp = await this.#api.get('getPaymentFolderUrl', { coachId: this.#coach.id });
            if (resp.success && resp.url) {
                window.open(UIManager.normalizeUrl(resp.url), "_blank");
            } else {
                UIManager.showToast("No folder found", 4000, "bg-red-600");
            }
        } catch (err) {
            UIManager.showToast("Error: " + err.message, 5000, "bg-red-600");
        } finally {
            UIManager.hideGlobalLoader();
        }
    }
    
    // ------------------- MODULO CALL LOG (Log Call) -------------------
    
    async loadStudentsForCallLog() {
        const select = UIManager.refs.callLogStudentSelect;
        if (!select) return;
        select.innerHTML = '<option value="" disabled selected>Loading students...</option>';

        try {
            const resp = await this.#api.get('getStudents');
            let arr = (resp && resp.success && Array.isArray(resp.students)) ? resp.students : [];
            
            arr.sort((a, b) => a.localeCompare(b, 'en', { sensitivity: 'base' }));

            select.innerHTML = '<option value="" disabled selected>Select a student</option>';
            arr.forEach(id => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = id;
                select.appendChild(opt);
            });
        } catch (err) {
            select.innerHTML = '<option value="" disabled selected>Error loading students</option>';
        }
    }
    
    async handleCallLogSubmission(e) {
        e.preventDefault();
        UIManager.hideMessage(UIManager.refs.callLogMessageBox);
        UIManager.showGlobalLoader();
        
        const form = UIManager.refs.callLogForm;
        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        data.coachId = this.#coach.id;
        
        // Logica di validazione originale
        if (!data.studentName || !data.date || !data.callType) {
             UIManager.showMessage(UIManager.refs.callLogMessageBox, "Please fill all required fields (Student, Date, Type).", false);
             UIManager.hideGlobalLoader();
             return;
        }

        try {
            const resp = await this.#api.post('submitCallLog', data);
            
            if (resp.success) {
                UIManager.showMessage(UIManager.refs.callLogMessageBox, "Call logged successfully!", true);
                form.reset();
                // Potrebbe essere necessario ricaricare la history
                this.handleViewCallHistory(); 
            } else {
                throw new Error(resp.error || 'Submission failed.');
            }
        } catch (err) {
            UIManager.showMessage(UIManager.refs.callLogMessageBox, `Submission failed: ${err.message}`, false);
        } finally {
            UIManager.hideGlobalLoader();
        }
    }

    // ------------------- MODULO HISTORY (Call History) -------------------
    
    async handleViewCallHistory() {
        if (!this.#coach.id) return;
        UIManager.switchSection(CONFIG.DOM_REFS.callHistorySection);
        const tableBody = UIManager.refs.callHistoryTableBody;
        if (!tableBody) return;
        
        tableBody.innerHTML = `<tr><td colspan="4">${UIManager.loaderHTML("Loading call history...")}</td></tr>`;
        UIManager.showGlobalLoader();
        
        try {
            const resp = await this.#api.get('getCallHistory', { coachId: this.#coach.id });
            if (resp.success && Array.isArray(resp.history)) {
                this.#callHistory = resp.history;
                this.renderHistoryTable();
            } else {
                tableBody.innerHTML = '<tr><td colspan="4" class="text-center p-4">No calls logged</td></tr>';
            }
        } catch (err) {
            tableBody.innerHTML = `<tr><td colspan="4" class="text-center p-4 text-red-500">Error: ${err.message}</td></tr>`;
        } finally {
            UIManager.hideGlobalLoader();
        }
    }

    renderHistoryTable() {
        const tableBody = UIManager.refs.callHistoryTableBody;
        const filter = UIManager.refs.historyMonthYear.value;
        if (!tableBody) return;

        let filteredHistory = this.#callHistory;

        if (filter) {
            filteredHistory = this.#callHistory.filter(call => {
                const callDate = new Date(call.date);
                const filterDate = new Date(filter);
                return callDate.getFullYear() === filterDate.getFullYear() && callDate.getMonth() === filterDate.getMonth();
            });
        }
        
        if (!filteredHistory.length) {
            tableBody.innerHTML = '<tr><td colspan="4" class="text-center p-4">No calls found for this period.</td></tr>';
            return;
        }

        const rows = filteredHistory.map(call => `
            <tr class="hover:bg-gray-50">
                <td class="px-6 py-4 whitespace-nowrap">${call.date}</td>
                <td class="px-6 py-4 whitespace-nowrap">${call.studentName}</td>
                <td class="px-6 py-4 whitespace-nowrap">${call.callType}</td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <button class="text-blue-600 hover:text-blue-900" 
                        onclick="window.appInstance.loadDebriefForCall('${call.studentName}', '${call.date}')">
                        View/Edit Debrief
                    </button>
                </td>
            </tr>
        `).join('');

        tableBody.innerHTML = rows;
    }
    
    // Funzione chiamata dal pulsante nella history
    loadDebriefForCall(studentName, date) {
        UIManager.refs.debriefStudentSelect.value = studentName;
        UIManager.refs.debriefDateInput.value = date;
        UIManager.switchSection(CONFIG.DOM_REFS.coachingDebriefSection);
        this.handleLoadDraftDebrief();
    }


    // ------------------- MODULO STUDENTI (Student info) -------------------
    
    handleViewStudents() {
        UIManager.switchSection(CONFIG.DOM_REFS.studentsSection);
        this.loadStudentsForInfoSection();
    }
    
    async loadStudentsForInfoSection() {
        // Usa la stessa logica di loadStudentsForCallLog ma con diversi elementi DOM
        const select = UIManager.refs.studentSelect;
        const container = UIManager.refs.studentDetailsContainer;
        if (!select || !container) return;
        
        select.innerHTML = '<option value="" disabled selected>Loading students...</option>';
        container.innerHTML = UIManager.loaderHTML("Select a student from the dropdown to view their details.");

        UIManager.showGlobalLoader();

        try {
            const resp = await this.#api.get('getStudents');
            let arr = (resp && resp.success && Array.isArray(resp.students)) ? resp.students : [];
            
            arr.sort((a, b, ) => a.localeCompare(b, 'en', { sensitivity: 'base' }));

            select.innerHTML = '<option value="" disabled selected>Select a student</option>';
            arr.forEach(id => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = id;
                select.appendChild(opt);
            });
        } catch (err) {
            select.innerHTML = '<option value="" disabled selected>Error loading students</option>';
            container.innerHTML = `<p class="text-red-500 text-center">Error loading students: ${err.message}</p>`;
        } finally {
            UIManager.hideGlobalLoader();
        }
    }

    async fetchAndRenderStudentDetails(studentId) {
        const container = UIManager.refs.studentDetailsContainer;
        if (!container) return;
        container.innerHTML = UIManager.loaderHTML("Loading student details...");
        UIManager.showGlobalLoader();

        try {
            const [infoResp, contractsResp] = await Promise.all([
                this.#api.get('getStudentInfo', { studentId }),
                this.#api.get('getStudentContracts', { studentId }).catch(e => ({ success: false, contracts: [] }))
            ]);

            if (!infoResp.success || !infoResp.studentInfo) {
                throw new Error(infoResp.error || "Student not found");
            }

            const info = infoResp.studentInfo;
            const calls = info.calls || [];
            delete info.calls;
            const contracts = contractsResp.success ? contractsResp.contracts : [];

            container.innerHTML = this.renderStudentDetailsHTML(studentId, info, calls, contracts); 

        } catch (err) {
            container.innerHTML = `<p class="text-red-500 text-center">Error: ${err.message}</p>`;
        } finally {
            UIManager.hideGlobalLoader();
        }
    }
    
    renderStudentDetailsHTML(studentId, info, calls, contracts) {
        // --- LOGICA ORIGINALE DI RENDERING DETTAGLI STUDENTE ---
        
        // Dati principali
        const infoHtml = Object.entries(info).map(([key, value]) => {
            const displayKey = UIManager.capitalize(key.replace(/([A-Z])/g, ' $1').trim());
            return `
                <div class="p-2 border-b">
                    <span class="font-semibold">${displayKey}:</span> 
                    <span>${UIManager.escapeHTML(value)}</span>
                </div>
            `;
        }).join('');
        
        // Contratti
        const contractRows = contracts.length ? contracts.map(c => `
            <tr>
                <td>${c.product || 'N/A'}</td>
                <td>${c.startDate || 'N/A'}</td>
                <td>${c.endDate || 'N/A'}</td>
                <td><a href="${UIManager.normalizeUrl(c.link)}" target="_blank" class="text-blue-500 hover:underline">View</a></td>
            </tr>
        `).join('') : '<tr><td colspan="4" class="text-center">No contracts found.</td></tr>';

        // History
        const callRows = calls.length ? calls.map(c => `
            <tr>
                <td>${c.date || 'N/A'}</td>
                <td>${c.type || 'N/A'}</td>
                <td><a href="#" onclick="window.appInstance.loadDebriefForCall('${studentId}', '${c.date}')" class="text-blue-500 hover:underline">View Debrief</a></td>
            </tr>
        `).join('') : '<tr><td colspan="3" class="text-center">No call history found.</td></tr>';


        return `
            <h3 class="text-xl font-bold mb-4">${UIManager.escapeHTML(studentId)} Details</h3>
            
            <div class="bg-white shadow rounded-lg p-6 mb-8">
                <h4 class="font-semibold text-lg mb-3 border-b pb-2">Student Info</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    ${infoHtml}
                </div>
            </div>

            <div class="bg-white shadow rounded-lg p-6 mb-8">
                <h4 class="font-semibold text-lg mb-3 border-b pb-2">Contracts</h4>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr><th>Product</th><th>Start Date</th><th>End Date</th><th>Link</th></tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">${contractRows}</tbody>
                    </table>
                </div>
            </div>
            
            <div class="bg-white shadow rounded-lg p-6">
                <h4 class="font-semibold text-lg mb-3 border-b pb-2">Call History</h4>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr><th>Date</th><th>Type</th><th>Debrief</th></tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">${callRows}</tbody>
                    </table>
                </div>
            </div>
        `;
    }

    // ------------------- MODULO DEBRIEF (Coaching Debrief) -------------------

    async handleViewDebrief() {
        UIManager.switchSection(CONFIG.DOM_REFS.coachingDebriefSection);
        
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        UIManager.refs.debriefDateInput.value = `${yyyy}-${mm}-${dd}`;
        
        await this.loadStudentsForDebrief();
    }
    
    async loadStudentsForDebrief() {
        // Usa la stessa logica di loadStudentsForCallLog ma con diversi elementi DOM
        const select = UIManager.refs.debriefStudentSelect;
        if (!select) return;
        select.innerHTML = '<option value="" disabled selected>Loading students...</option>';

        UIManager.showGlobalLoader();

        try {
            const resp = await this.#api.get('getStudents');
            let arr = (resp && resp.success && Array.isArray(resp.students)) ? resp.students : [];
            
            arr.sort((a, b) => a.localeCompare(b, 'en', { sensitivity: 'base' }));

            select.innerHTML = '<option value="" disabled selected>Select a student</option>';
            arr.forEach(id => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = id;
                select.appendChild(opt);
            });
        } catch (err) {
            select.innerHTML = '<option value="" disabled selected>Error loading students</option>';
        } finally {
            UIManager.hideGlobalLoader();
        }
    }
    
    async handleSaveDraftDebrief(e) {
        if(e) e.preventDefault();
        UIManager.hideMessage(UIManager.refs.debriefMsg);
        
        const form = UIManager.refs.debriefForm;
        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        data.coachId = this.#coach.id;

        if (!data.studentName || !data.date) {
            UIManager.showMessage(UIManager.refs.debriefMsg, "Student and Date are required to save a draft.", false);
            return;
        }
        
        UIManager.showGlobalLoader();
        try {
            const resp = await this.#api.post('saveDebriefDraft', data);
            
            if (resp.success) {
                UIManager.showToast("Draft saved successfully!", 3000, "bg-green-600");
                this.handleLoadDraftDebrief(); // Ricarica la lista bozze
            } else {
                throw new Error(resp.error || 'Failed to save draft.');
            }
        } catch (err) {
            UIManager.showMessage(UIManager.refs.debriefMsg, `Error saving draft: ${err.message}`, false);
        } finally {
            UIManager.hideGlobalLoader();
        }
    }

    async handleLoadDraftDebrief() {
        const student = UIManager.refs.debriefStudentSelect.value;
        const date = UIManager.refs.debriefDateInput.value;
        const container = UIManager.refs.debriefDraftsContainer;
        if (!container) return;
        
        container.innerHTML = UIManager.loaderHTML("Loading drafts...");
        this.#debriefLoadedRow = null;
        
        if (!student) {
            container.innerHTML = "<p class='text-gray-500'>Select a student to load drafts.</p>";
            return;
        }

        try {
            const resp = await this.#api.get('getDebriefDrafts', { coachId: this.#coach.id, studentName: student, date: date });
            
            if (resp.success && Array.isArray(resp.drafts)) {
                container.innerHTML = this.renderDraftsList(resp.drafts);
            } else {
                container.innerHTML = "<p class='text-gray-500'>No drafts found.</p>";
            }
        } catch (err) {
            container.innerHTML = `<p class="text-red-500">Error loading drafts: ${err.message}</p>`;
        }
    }

    renderDraftsList(drafts) {
        if (!drafts.length) return "<p class='text-gray-500'>No drafts found.</p>";
        
        // Logica per mostrare l'elenco e i pulsanti "Load"
        const rows = drafts.map(draft => {
            const summary = draft.content.substring(0, 100) + '...';
            return `
                <div class="border p-3 mb-2 rounded flex justify-between items-center bg-gray-50">
                    <div>
                        <p class="font-semibold">${draft.timestamp || 'N/A'}</p>
                        <p class="text-sm text-gray-600">${UIManager.escapeHTML(summary)}</p>
                    </div>
                    <button class="bg-blue-500 hover:bg-blue-600 text-white text-sm py-1 px-3 rounded"
                        onclick="window.appInstance.applyDraftToForm(${JSON.stringify(draft)})">
                        Load
                    </button>
                </div>
            `;
        }).join('');
        
        return `<div class="mt-4 max-h-60 overflow-y-auto">${rows}</div>`;
    }
    
    applyDraftToForm(draft) {
        // Assume che il 'draft' contenga tutti i campi del form
        const form = UIManager.refs.debriefForm;
        if (!form) return;
        
        for (const [key, value] of Object.entries(draft)) {
            const input = form.elements[key];
            if (input) {
                input.value = value;
            }
        }
        this.#debriefLoadedRow = draft; // Salva la bozza caricata per riferimento
        UIManager.showToast("Draft loaded into form.", 3000, "bg-green-600");
    }

    async handleSendDebrief(e) {
        e.preventDefault();
        UIManager.hideMessage(UIManager.refs.debriefMsg);
        
        const form = UIManager.refs.debriefForm;
        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        data.coachId = this.#coach.id;
        
        if (!data.studentName || !data.date || !data.content) {
            UIManager.showMessage(UIManager.refs.debriefMsg, "Student, Date, and Content are required to send the debrief.", false);
            return;
        }

        UIManager.showGlobalLoader();
        try {
            const resp = await this.#api.post('sendDebrief', data);
            
            if (resp.success) {
                UIManager.showMessage(UIManager.refs.debriefMsg, "Debrief sent successfully!", true);
                form.reset();
                this.handleLoadDraftDebrief(); // Pulisce la lista bozze
            } else {
                throw new Error(resp.error || 'Failed to send debrief.');
            }
        } catch (err) {
            UIManager.showMessage(UIManager.refs.debriefMsg, `Error sending debrief: ${err.message}`, false);
        } finally {
            UIManager.hideGlobalLoader();
        }
    }
    
    // Funzione placeholder per l'AI Preview (basata su un pattern comune)
    async handleAIPreview(fieldName) {
        const student = UIManager.refs.debriefStudentSelect.value;
        const content = document.querySelector(`[name="${fieldName}"]`)?.value;
        const previewContainer = UIManager.refs.debriefAIPreviewContainer;

        if (!student || !content) {
            UIManager.showToast("Select a student and fill the content first.", 3000, "bg-yellow-600");
            return;
        }

        previewContainer.innerHTML = UIManager.loaderHTML("Generating AI preview...");
        
        try {
            const resp = await this.#api.post('aiGenerateDebriefSection', {
                coachId: this.#coach.id,
                studentName: student,
                fieldName: fieldName,
                context: content 
            });
            
            if (resp.success && resp.suggestion) {
                // Implementazione del rendering dell'AI suggestion con pulsanti
                previewContainer.innerHTML = `
                    <div class="border p-4 rounded bg-yellow-50">
                        <p class="font-bold">AI Suggestion for ${UIManager.capitalize(fieldName)}:</p>
                        <p class="mt-2 whitespace-pre-wrap">${UIManager.escapeHTML(resp.suggestion)}</p>
                        <div class="mt-4 flex gap-2">
                            <button class="bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded"
                                onclick="window.appInstance.applyAISuggestion('${fieldName}', \`${UIManager.escapeBackticks(resp.suggestion)}\`)">
                                Apply
                            </button>
                            <button class="bg-red-500 hover:bg-red-600 text-white py-1 px-3 rounded"
                                onclick="window.appInstance.discardAISuggestion()">
                                Discard
                            </button>
                        </div>
                    </div>
                `;
            } else {
                previewContainer.innerHTML = `<p class="text-red-500">AI failed: ${resp.error || 'Unknown error'}</p>`;
            }
        } catch (err) {
            previewContainer.innerHTML = `<p class="text-red-500">Error: ${err.message}</p>`;
        }
    }
    
    applyAISuggestion(fieldName, suggestion) {
        document.querySelector(`[name="${fieldName}"]`).value = suggestion;
        this.discardAISuggestion();
        UIManager.showToast("Suggestion applied.", 2000, "bg-green-600");
    }
    
    discardAISuggestion() {
        UIManager.refs.debriefAIPreviewContainer.innerHTML = "";
    }


    // ------------------- MODULO FLASHCARDS -------------------
    
    handleViewFlashcards() {
        UIManager.switchSection(CONFIG.DOM_REFS.flashcardsSection);
        this.initFlashcardsLogic(); 
    }

    async initFlashcardsLogic() {
        const container = UIManager.refs.flashcardsContainer;
        const select = UIManager.refs.flashcardsStudentSelect;
        if (!container || !select) return;

        container.innerHTML = UIManager.loaderHTML("Loading students...");
        select.innerHTML = '<option value="" disabled selected>Loading students...</option>';

        UIManager.showGlobalLoader();
        try {
            const resp = await this.#api.get('getStudents');
            let students = (resp && resp.success && Array.isArray(resp.students)) ? resp.students : [];
            
            students.sort((a, b) => a.localeCompare(b, 'en', { sensitivity: 'base' }));

            select.innerHTML = '<option value="" disabled selected>Select a student</option>';
            students.forEach(id => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = id;
                select.appendChild(opt);
            });
            
            container.innerHTML = "<p class='text-gray-500 text-center'>Select a student to start the Flashcard session.</p>";

            // Listener per l'avvio della sessione
            select.addEventListener('change', () => this.startFlashcardSession(select.value));

        } catch (err) {
             container.innerHTML = `<p class="text-red-500 text-center">Error loading students: ${err.message}</p>`;
        } finally {
            UIManager.hideGlobalLoader();
        }
    }

    async startFlashcardSession(studentId) {
        const container = UIManager.refs.flashcardsContainer;
        container.innerHTML = UIManager.loaderHTML("Loading flashcards...");
        
        try {
            const resp = await this.#api.get('getFlashcards', { studentId: studentId });
            
            if (!resp.success || !Array.isArray(resp.cards)) {
                throw new Error(resp.error || "Failed to load flashcards.");
            }
            
            // --- LOGICA DI STATO E DECK ORIGINALE ---
            this.#cardsByEn = new Map(resp.cards.map(c => [String(c.en || "").toLowerCase(), c]));
            
            // Reinizializza lo stato per la nuova sessione
            this.#pendingFlashcardUpdates = [];
            this.#stepIndex = 0;
            this.#sessionTotalSteps = 20;
            
            this.#currentDeck = this.buildSmartDeck(resp.cards);
            
            const renderCard = (step, total, card) => {
                UIManager.refs.flashcardStepDisplay.textContent = step + 1;
                UIManager.refs.flashcardDeckTotal.textContent = total;
                UIManager.refs.flashcardProgress.style.width = `${((step + 1) / total) * 100}%`;
                
                UIManager.refs.flashcardFront.textContent = UIManager.escapeHTML(card.en);
                UIManager.refs.flashcardBack.textContent = UIManager.escapeHTML(card.it);
                
                // Nasconde i pulsanti "Send" e "Retry Reds"
                UIManager.refs.flashcardSendUpdatesBtn.classList.add('hidden');
                UIManager.refs.flashcardRetryRedsBtn.classList.add('hidden');
                UIManager.refs.flashcardCardContainer.classList.remove('flipped');
                UIManager.refs.flashcardControlsContainer.classList.remove('hidden');

                UIManager.refs.flashcardGoodBtn.onclick = () => this.updateFlashcardScore(card, 'good');
                UIManager.refs.flashcardBadBtn.onclick = () => this.updateFlashcardScore(card, 'bad');
                
                // Toggle card flip listener
                UIManager.refs.flashcardCardContainer.onclick = () => UIManager.refs.flashcardCardContainer.classList.toggle('flipped');
            };

            // Funzione di rendering principale (sessionTotalSteps √® inizialmente 20)
            this.#renderNextCard = () => {
                if (this.#stepIndex >= this.#sessionTotalSteps) {
                    this.renderFlashcardSessionComplete();
                    return;
                }
                
                const next = this.pickCardFromSmartDeck(this.#currentDeck);
                renderCard(this.#stepIndex, this.#sessionTotalSteps, next);
                this.#stepIndex++;
            };
            
            // üöÄ Avvia la prima carta
            this.#renderNextCard();

        } catch (err) {
            container.innerHTML = `<p class="text-red-500 text-center">Error loading flashcards: ${err.message}</p>`;
        }
    }

    buildSmartDeck(cards) {
        const deck = [];
        const now = Date.now();
        
        cards.forEach(card => {
            const lastReview = card.lastReview ? new Date(card.lastReview).getTime() : 0;
            const score = Math.max(card.score || 1, 1); // Min score 1

            // Logica di priorit√†:
            // Pi√π basso √® lo score, pi√π frequentemente appare (es. 10/score)
            // Pi√π √® vecchio, pi√π alta √® la priorit√† (es. (now - lastReview) / 1000)
            const priority = (now - lastReview) / (score * 86400000) + (10 / score);
            
            for (let i = 0; i < Math.min(Math.ceil(priority), 15); i++) {
                deck.push(card);
            }
        });
        
        // Shuffle (randomizzazione per evitare pattern prevedibili)
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        
        return deck;
    }

    pickCardFromSmartDeck(deck) {
        if (!deck || deck.length === 0) {
            // Se il deck √® vuoto, usa un fallback (es. una carta a caso dalle cards originali)
            const fallback = Array.from(this.#cardsByEn.values());
            return fallback[Math.floor(Math.random() * fallback.length)];
        }
        
        // Logica per prendere una carta dal deck (potrebbe essere un semplice pop/shift)
        return deck.shift();
    }
    
    updateFlashcardScore(card, status) {
        // Rimuovi eventuali vecchi update per la stessa carta in questa sessione
        this.#pendingFlashcardUpdates = this.#pendingFlashcardUpdates.filter(u => u.en !== card.en);
        
        let newScore = card.score;
        if (status === 'good') {
            newScore = Math.min((newScore || 1) + 1, 15); // Max score 15
        } else if (status === 'bad') {
            newScore = Math.max((newScore || 1) - 1, 1); // Min score 1
        }
        
        this.#pendingFlashcardUpdates.push({
            en: card.en,
            score: newScore,
            status: status // 'good', 'bad', o 'unknown' (per il retry)
        });
        
        // Aggiorna lo score locale per la sessione successiva (se non inviata)
        card.score = newScore;
        card.lastReview = new Date().toISOString().split('T')[0];
        
        this.#renderNextCard();
    }
    
    renderFlashcardSessionComplete() {
        UIManager.refs.flashcardCardContainer.innerHTML = `
            <div class="p-8 text-center">
                <h3 class="text-2xl font-bold text-green-600 mb-4">Session Complete!</h3>
                <p>You reviewed ${this.#sessionTotalSteps} cards.</p>
                <p class="mt-2">Ready to save your progress?</p>
            </div>
        `;
        UIManager.refs.flashcardControlsContainer.classList.add('hidden');
        UIManager.refs.flashcardSendUpdatesBtn.classList.remove('hidden');
        
        // Mostra il pulsante "Retry Reds" solo se ci sono state risposte "Bad"
        if (this.#pendingFlashcardUpdates.some(u => u.status === 'bad')) {
            UIManager.refs.flashcardRetryRedsBtn.classList.remove('hidden');
        } else {
             UIManager.refs.flashcardRetryRedsBtn.classList.add('hidden');
        }
        
    }

    async sendFlashcardUpdates() {
        if (this.#pendingFlashcardUpdates.length === 0) {
            UIManager.showToast("No changes to save.", 3000, "bg-yellow-600");
            return;
        }

        UIManager.showGlobalLoader();
        try {
            const updates = this.#pendingFlashcardUpdates.map(u => ({
                en: u.en,
                score: u.score,
                lastReview: new Date().toISOString().split('T')[0],
            }));
            
            const studentId = UIManager.refs.flashcardsStudentSelect.value;
            const resp = await this.#api.post('updateFlashcardScores', { studentId, updates });
            
            if (resp.success) {
                UIManager.showToast("Progress saved successfully!", 3000, "bg-green-600");
                this.initFlashcardsLogic(); // Riavvia la sezione per una nuova selezione
            } else {
                throw new Error(resp.error || 'Failed to save progress.');
            }
        } catch (err) {
            UIManager.showToast(`Error saving progress: ${err.message}`, 5000, "bg-red-600");
        } finally {
            UIManager.hideGlobalLoader();
        }
    }
    
    handleRetryReds() {
        const redCards = this.#pendingFlashcardUpdates
          .filter(c => c.status === "bad") // Usa "bad" come nell'originale, non "unknown"
          .map(u => this.#cardsByEn.get(String(u.en || "").toLowerCase()))
          .filter(Boolean);

        if (!redCards.length) return;
        
        // Reset della sessione
        this.#pendingFlashcardUpdates = [];
        this.#stepIndex = 0;
        this.#sessionTotalSteps = 10; // Nuovo totale per il retry (come nell'originale)

        const redDeck = this.buildSmartDeck(redCards);
        
        // Sovrascrive la funzione per usare il deck e il totale corretti
        const renderNextRed = () => {
            if (this.#stepIndex >= this.#sessionTotalSteps) {
                this.renderFlashcardSessionComplete();
                return;
            }
            const next = this.pickCardFromSmartDeck(redDeck);
            // Non incrementare lo score per le carte rosse (il vero score √® quello del deck)
            UIManager.refs.flashcardStepDisplay.textContent = this.#stepIndex + 1;
            UIManager.refs.flashcardDeckTotal.textContent = this.#sessionTotalSteps;
            // ... (altri aggiornamenti UI)
            
            // Re-bind degli handler per usare la logica di update corretta
            UIManager.refs.flashcardGoodBtn.onclick = () => this.updateFlashcardScore(next, 'good');
            UIManager.refs.flashcardBadBtn.onclick = () => this.updateFlashcardScore(next, 'bad');
            
            this.#stepIndex++;
        };

        // Assegna la nuova logica per il prossimo round
        this.#renderNextCard = renderNextRed;
        this.#renderNextCard();
    }


    // ------------------- GESTIONE EVENTI (Event Listeners) -------------------

    initEventListeners() {
        // Rendi accessibili le funzioni globali (necessario se chiamate da HTML inline)
        window.appInstance = this;
        window.handleGoogleLogin = this.handleGoogleLogin.bind(this);
        
        // Auth
        UIManager.refs.loginForm?.addEventListener('submit', (e) => this.handleManualLogin(e));
        UIManager.refs.logoutBtn?.addEventListener('click', () => this.handleLogout());

        // Navigazione Menu
        document.getElementById('viewDashboardBtn')?.addEventListener('click', () => UIManager.switchSection(CONFIG.DOM_REFS.dashboardSection));
        document.getElementById('viewStudentsBtn')?.addEventListener('click', () => this.handleViewStudents());
        UIManager.refs.viewFolderBtn?.addEventListener('click', () => this.handleViewFolder());
        document.getElementById('viewCallLogBtn')?.addEventListener('click', () => UIManager.switchSection(CONFIG.DOM_REFS.callSection));
        document.getElementById('viewCallHistoryBtn')?.addEventListener('click', () => this.handleViewCallHistory());
        document.getElementById('viewCoachingDebriefBtn')?.addEventListener('click', () => this.handleViewDebrief());
        document.getElementById('viewFlashcardsBtn')?.addEventListener('click', () => this.handleViewFlashcards());

        // Sezione Studenti
        UIManager.refs.studentSelect?.addEventListener('change', (e) => {
            if (e.target.value) this.fetchAndRenderStudentDetails(e.target.value);
        });

        // Sezione Call Log
        UIManager.refs.callLogForm?.addEventListener('submit', (e) => this.handleCallLogSubmission(e));

        // Sezione History (filtro)
        UIManager.refs.historyMonthYear?.addEventListener('change', () => this.renderHistoryTable());
        
        // Sezione Debrief
        UIManager.refs.debriefForm?.addEventListener('submit', (e) => this.handleSendDebrief(e));
        UIManager.refs.debriefSaveDraftBtn?.addEventListener('click', (e) => this.handleSaveDraftDebrief(e));
        UIManager.refs.debriefLoadDraftsBtn?.addEventListener('click', () => this.handleLoadDraftDebrief());
        UIManager.refs.debriefStudentSelect?.addEventListener('change', () => this.handleLoadDraftDebrief());
        UIManager.refs.debriefDateInput?.addEventListener('change', () => this.handleLoadDraftDebrief());
        
        // Sezione Flashcards
        UIManager.refs.flashcardSendUpdatesBtn?.addEventListener('click', () => this.sendFlashcardUpdates());
        UIManager.refs.flashcardRetryRedsBtn?.addEventListener('click', () => this.handleRetryReds());
    }
}

// --------------------------------------------------------------------
// 5. INIZIALIZZAZIONE GLOBALE
// --------------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    const app = new DashboardApp();
    app.init();
});
